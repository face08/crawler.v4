var refVal0 = refVal[0]; var refVal1 = refVal[1]; var customRule0 = customRules[0];
var customRule1 = customRules[1]; var validate = (async function (data, dataPath, parentData, parentDataProperty, rootData) {
    'use strict';  /*# sourceURL=test */  var vErrors = null; var errors = 0;
    if (rootData === undefined) rootData = data; if ((data && typeof data === "object" && !Array.isArray(data))) {
        if (data.name === undefined) data.name = "nora"; if (data.boolean === undefined) data.boolean = true;
        if (data.object === undefined) data.object = {}; if (data.null === undefined) data.null = null; var errs__0 = errors; var valid1 = true; for (var key0 in data) {
            var isAdditional0 = !(false || validate.schema.properties[key0]);
        } var data1 = data.name; var errs_1 = errors; if (typeof data1 !== "string") {
            var dataType1 = typeof data1; var coerced1 = undefined;
            if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1; else if (data1 === null) coerced1 = ''; if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/name', schemaPath: '#/properties/name/type', params: { type: 'string' }, message: 'should be string' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['name'] = coerced1; }
        } var valid1 = errors === errs_1; var data1 = data.number; if (data1 !== undefined) { var errs_1 = errors; if (typeof data1 !== "number") { var dataType1 = typeof data1; var coerced1 = undefined; if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1)) coerced1 = +data1; if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/number', schemaPath: '#/properties/number/type', params: { type: 'number' }, message: 'should be number' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['number'] = coerced1; } } var valid1 = errors === errs_1; } var data1 = data.integer; if (data1 !== undefined) { var errs_1 = errors; if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) { var dataType1 = typeof data1; var coerced1 = undefined; if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1; if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/integer', schemaPath: '#/properties/integer/type', params: { type: 'integer' }, message: 'should be integer' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['integer'] = coerced1; } } var valid1 = errors === errs_1; } var data1 = data.boolean; var errs_1 = errors; if (typeof data1 !== "boolean") { var dataType1 = typeof data1; var coerced1 = undefined; if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false; else if (data1 === 'true' || data1 === 1) coerced1 = true; if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/boolean', schemaPath: '#/properties/boolean/type', params: { type: 'boolean' }, message: 'should be boolean' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['boolean'] = coerced1; } } var valid1 = errors === errs_1; var data1 = data.object; var errs_1 = errors; if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) {
            if (data1.settings === undefined)
                data1.settings = true;
            var errs__1 = errors;
            var valid2 = true; for (var key1 in data1) {
                var isAdditional1 = !(false || key1 == 'settings');
            } var data2 = data1.settings; var errs_2 = errors; if (typeof data2 !== "boolean") { var dataType2 = typeof data2; var coerced2 = undefined; if (data2 === 'false' || data2 === 0 || data2 === null) coerced2 = false; else if (data2 === 'true' || data2 === 1) coerced2 = true; if (coerced2 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/object/settings', schemaPath: '#/properties/object/properties/settings/type', params: { type: 'boolean' }, message: 'should be boolean' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data2 = coerced2; data1['settings'] = coerced2; } } var schema2 = validate.schema.properties.object.properties.settings.enum; var valid2; valid2 = false; for (var i2 = 0; i2 < schema2.length; i2++) if (equal(data2, schema2[i2])) { valid2 = true; break; } if (!valid2) { var err = { keyword: 'enum', dataPath: (dataPath || '') + '/object/settings', schemaPath: '#/properties/object/properties/settings/enum', params: { allowedValues: schema2 }, message: 'should be equal to one of the allowed values' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid2 = errors === errs_2;
        } else { var err = { keyword: 'type', dataPath: (dataPath || '') + '/object', schemaPath: '#/properties/object/type', params: { type: 'object' }, message: 'should be object' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid1 = errors === errs_1; var data1 = data.array; if (data1 !== undefined) { var errs_1 = errors; if (Array.isArray(data1)) { var errs__1 = errors; var valid1; for (var i1 = 0; i1 < data1.length; i1++) { var data2 = data1[i1]; var errs_2 = errors; if (typeof data2 !== "string") { var dataType2 = typeof data2; var coerced2 = undefined; if (dataType2 == 'number' || dataType2 == 'boolean') coerced2 = '' + data2; else if (data2 === null) coerced2 = ''; if (coerced2 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/array/' + i1, schemaPath: '#/properties/array/items/type', params: { type: 'string' }, message: 'should be string' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data2 = coerced2; data1[i1] = coerced2; } } if (typeof data2 === "string") { if (ucs2length(data2) < 3) { var err = { keyword: 'minLength', dataPath: (dataPath || '') + '/array/' + i1, schemaPath: '#/properties/array/items/minLength', params: { limit: 3 }, message: 'should NOT be shorter than 3 characters' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } var valid2 = errors === errs_2; } } else { var err = { keyword: 'type', dataPath: (dataPath || '') + '/array', schemaPath: '#/properties/array/type', params: { type: 'array' }, message: 'should be array' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid1 = errors === errs_1; } var data1 = data.array1; if (data1 !== undefined) {
            var errs_1 = errors; if (Array.isArray(data1)) {
                var errs__1 = errors; var valid1; for (var i1 = 0; i1 < data1.length; i1++) {
                    var data2 = data1[i1]; var errs_2 = errors; if ((data2 && typeof data2 === "object" && !Array.isArray(data2))) {
                        var errs__2 = errors; var valid3 = true; for (var key2 in data2) { var isAdditional2 = !(false || key2 == 'test' || key2 == 'children'); }
                        var data3 = data2.test; if (data3 === undefined) { valid3 = false; var err = { keyword: 'required', dataPath: (dataPath || '') + '/array1/' + i1 + '/test', schemaPath: '#/properties/array1/items/required', params: { missingProperty: 'test' }, message: 'is a required property' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {
                            var errs_3 = errors;
                            if (typeof data3 !== "string") { var dataType3 = typeof data3; var coerced3 = undefined; if (dataType3 == 'number' || dataType3 == 'boolean') coerced3 = '' + data3; else if (data3 === null) coerced3 = ''; if (coerced3 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/array1/' + i1 + '/test', schemaPath: '#/properties/array1/items/properties/test/type', params: { type: 'string' }, message: 'should be string' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data3 = coerced3; data2['test'] = coerced3; } } if (typeof data3 === "string") {
                                if (ucs2length(data3) < 3) { var err = { keyword: 'minLength', dataPath: (dataPath || '') + '/array1/' + i1 + '/test', schemaPath: '#/properties/array1/items/properties/test/minLength', params: { limit: 3 }, message: 'should NOT be shorter than 3 characters' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } customRule0.errors = null;
                                var errs__3 = errors; var valid3; var customErrors3 = null; try { valid3 = await customRule0.call(self, validate.schema.properties.array1.items.properties.test.idExists, data3, validate.schema.properties.array1.items.properties.test, (dataPath || '') + '/array1/' + i1 + '/test', data2, 'test', rootData); } catch (e) { valid3 = false; if (e instanceof ValidationError) customErrors3 = e.errors; else throw e; } if (!valid3) {
                                    if (Array.isArray(customErrors3)) {
                                        if (vErrors === null) vErrors = customErrors3;
                                        else vErrors = vErrors.concat(customErrors3); errors = vErrors.length; for (var i3 = errs__3; i3 < errors; i3++) { var ruleErr3 = vErrors[i3]; if (ruleErr3.dataPath === undefined) ruleErr3.dataPath = (dataPath || '') + '/array1/' + i1 + '/test'; ruleErr3.schemaPath = "#/properties/array1/items/properties/test/idExists"; }
                                    } else { var err = { keyword: 'idExists', dataPath: (dataPath || '') + '/array1/' + i1 + '/test', schemaPath: '#/properties/array1/items/properties/test/idExists', params: { keyword: 'idExists' }, message: 'should pass "idExists" keyword validation' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }
                                }
                            } var valid3 = errors === errs_3;
                        } if (data2.children !== undefined) { var errs_3 = errors; try { await refVal1(data2.children, (dataPath || '') + '/array1/' + i1 + '/children', data2, 'children', rootData); } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } var valid3 = errors === errs_3; }
                    } else { var err = { keyword: 'type', dataPath: (dataPath || '') + '/array1/' + i1, schemaPath: '#/properties/array1/items/type', params: { type: 'object' }, message: 'should be object' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid2 = errors === errs_2;
                }
            } else { var err = { keyword: 'type', dataPath: (dataPath || '') + '/array1', schemaPath: '#/properties/array1/type', params: { type: 'array' }, message: 'should be array' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid1 = errors === errs_1;
        } var data1 = data.null; var errs_1 = errors; if (data1 !== null) { var dataType1 = typeof data1; var coerced1 = undefined; if (data1 === '' || data1 === 0 || data1 === false) coerced1 = null; if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/null', schemaPath: '#/properties/null/type', params: { type: 'null' }, message: 'should be null' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['null'] = coerced1; } } var valid1 = errors === errs_1; var data1 = data.muti; if (data1 !== undefined) {
            var errs_1 = errors; if (typeof data1 !== "string" && typeof data1 !== "number") {
                var dataType1 = typeof data1; var coerced1 = undefined; if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
                else if (data1 === null) coerced1 = ''; if (coerced1 === undefined) { if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1; if (coerced1 === undefined) { if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1)) coerced1 = +data1; } } if (coerced1 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/muti', schemaPath: '#/properties/muti/type', params: { type: 'string,integer,number' }, message: 'should be string,integer,number' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data1 = coerced1; data['muti'] = coerced1; }
            } var valid1 = errors === errs_1;
        } var data1 = data.geo; if (data1 !== undefined) { var errs_1 = errors; if ((data1 && typeof data1 === "object" && !Array.isArray(data1))) { var errs__1 = errors; var valid2 = true; for (var key1 in data1) { var isAdditional1 = !(false || key1 == 'lou' || key1 == 'lat'); } var data2 = data1.lou; if (data2 === undefined) { valid2 = false; var err = { keyword: 'required', dataPath: (dataPath || '') + '/geo/lou', schemaPath: '#/properties/geo/required', params: { missingProperty: 'lou' }, message: 'is a required property' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { var errs_2 = errors; if (typeof data2 !== "number") { var dataType2 = typeof data2; var coerced2 = undefined; if (dataType2 == 'boolean' || data2 === null || (dataType2 == 'string' && data2 && data2 == +data2)) coerced2 = +data2; if (coerced2 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/geo/lou', schemaPath: '#/properties/geo/properties/lou/type', params: { type: 'number' }, message: 'should be number' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data2 = coerced2; data1['lou'] = coerced2; } } if (typeof data2 === "number") { if (data2 > 100 || data2 !== data2) { var err = { keyword: 'maximum', dataPath: (dataPath || '') + '/geo/lou', schemaPath: '#/properties/geo/properties/lou/maximum', params: { comparison: '<=', limit: 100, exclusive: false }, message: 'should be <= 100' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } if (data2 < 0 || data2 !== data2) { var err = { keyword: 'minimum', dataPath: (dataPath || '') + '/geo/lou', schemaPath: '#/properties/geo/properties/lou/minimum', params: { comparison: '>=', limit: 0, exclusive: false }, message: 'should be >= 0' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } var valid2 = errors === errs_2; } var data2 = data1.lat; if (data2 === undefined) { valid2 = false; var err = { keyword: 'required', dataPath: (dataPath || '') + '/geo/lat', schemaPath: '#/properties/geo/required', params: { missingProperty: 'lat' }, message: 'is a required property' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { var errs_2 = errors; if (typeof data2 !== "number") { var dataType2 = typeof data2; var coerced2 = undefined; if (dataType2 == 'boolean' || data2 === null || (dataType2 == 'string' && data2 && data2 == +data2)) coerced2 = +data2; if (coerced2 === undefined) { var err = { keyword: 'type', dataPath: (dataPath || '') + '/geo/lat', schemaPath: '#/properties/geo/properties/lat/type', params: { type: 'number' }, message: 'should be number' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { data2 = coerced2; data1['lat'] = coerced2; } } var valid2 = errors === errs_2; } } else { var err = { keyword: 'type', dataPath: (dataPath || '') + '/geo', schemaPath: '#/properties/geo/type', params: { type: 'object' }, message: 'should be object' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } var valid1 = errors === errs_1; }
    } else { var err = { keyword: 'type', dataPath: (dataPath || '') + "", schemaPath: '#/type', params: { type: 'object' }, message: 'should be object' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } if (errors === 0) return data; else throw new ValidationError(vErrors);
}); return validate;